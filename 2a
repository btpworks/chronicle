use std::convert::Infallible;
use std::hint::unreachable_unchecked;

use async_std::task::block_on;
use custom_error::custom_error;
use futures::future::{self, BoxFuture};
use futures::FutureExt;
use iref::{AsIri, Iri, IriBuf, IriRef};
use json::JsonValue;
use json_ld::context::RemoteContext;
use json_ld::{context::Local, Document, JsonContext, NoLoader};
use json_ld::{Error, ErrorCode, Indexed, Loader, Node, Reference, RemoteDocument};

use crate::models::{ChronicleTransaction, ProvModel};
use crate::vocab::Prov;

custom_error! {pub SubmissionError
    Implementation{source: Box<dyn std::error::Error>} = "Ledger error",
}

custom_error! {pub ProcessorError
    JsonLd{source: json_ld::Error} = "Json Ld Error",
}

impl From<Infallible> for ProcessorError {
    fn from(_: Infallible) -> Self {
        unreachable!()
    }
}

pub trait LedgerWriter {
    fn submit(&self, tx: Vec<&ChronicleTransaction>) -> Result<(), SubmissionError>;
}

/// An in memory ledger implementation for development and testing purposes
#[derive(Debug, Default)]
pub struct InMemLedger {}

impl LedgerWriter for InMemLedger {
    fn submit(&self, _tx: Vec<&ChronicleTransaction>) -> Result<(), SubmissionError> {
        Ok(())
    }
}

pub struct OutputAddress(pub String);

impl std::ops::Deref for OutputAddress {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

pub struct InputAddress(pub String);

impl std::ops::Deref for InputAddress {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

pub trait Depdendencies {
    fn dependencies(&self) -> (Vec<InputAddress>, Vec<OutputAddress>);
}

pub struct StateInput {
    address: InputAddress,
    data: Vec<u8>,
}

impl StateInput {
    pub fn new(address: InputAddress, data: Vec<u8>) -> Self {
        Self { address, data }
    }
}

pub struct StateOutput {
    address: InputAddress,
    data: Vec<u8>,
}

impl StateOutput {
    pub fn new(address: InputAddress, data: Vec<u8>) -> Self {
        Self { address, data }
    }
}

/// Abstract state processing independent of any particular ledger implementation.
pub trait Processor {
    fn process<I, O>(&self, input: I) -> Result<O, ProcessorError>
    where
        I: IntoIterator<Item = StateInput>,
        O: IntoIterator<Item = StateOutput>;
}

/// A prov model represented as one or more JSON-LD documents
pub trait JsonLdState {
    /// Take a Json-Ld input document, assuming it is in compact form, expand it and apply the state to the prov model
    /// Replace @context with our resource context
    /// We rely on reified @types, so subclassing must also include supertypes
    fn apply_json_ld(&mut self, json: JsonValue) -> Result<(), ProcessorError> {
        json.remove("@context");
        json.insert("@context", crate::context::PROV.clone());
        let model = ProvModel::default();
        let output = block_on(json.expand::<JsonContext, _>(&mut NoLoader))?;

        for o in output {
            let o = o.try_cast::<Node>()?.inner();
            if o.has_type(&Reference::Id(Prov::Agent.as_iri().into())) {
                self.apply_node_as_agent(&mut model, o)?;
            } else if o.has_type(&Reference::Id(Prov::Activity.as_iri().into())) {
                self.apply_node_as_activity(&mut model, o)?;
            } else if o.has_type(&Reference::Id(Prov::Entity.as_iri().into())) {
                self.apply_node_as_entity(o)?;
            }
        }

        Ok(())
    }

    fn apply_node_as_agent(
        &self,
        model: &mut ProvModel,
        agent: &Node,
    ) -> Result<(), ProcessorError> {
    }

    fn apply_node_as_activity(
        &self,
        model: &mut ProvModel,
        activity: &Node,
    ) -> Result<(), ProcessorError> {
    }

    fn apply_node_as_entity(
        &self,
        model: &mut ProvModel,
        entity: &Node,
    ) -> Result<(), ProcessorError> {
    }
}

impl Depdendencies for ChronicleTransaction {
    fn dependencies(&self) -> (Vec<InputAddress>, Vec<OutputAddress>) {
        todo!()
    }
}

impl Processor for ChronicleTransaction {
    fn process<I, O>(&self, input: I) -> Result<O, ProcessorError>
    where
        I: IntoIterator<Item = StateInput>,
        O: IntoIterator<Item = StateOutput>,
    {
        let model = ProvModel::default();
    }
}

