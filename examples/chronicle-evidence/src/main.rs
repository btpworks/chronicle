use chronicle ::tokio ;
use chronicle::api::chronicle_graphql :: { self, ChronicleGraphQl } ;
use chronicle::async_graphql :: { self, NewType } ;
use chronicle::async_graphql::connection ;
use chronicle::bootstrap ::bootstrap ;
use chronicle::chrono ;
use chronicle::codegen ::ChronicleDomainDef ;
use chronicle::common::attributes ;
use chronicle::common::prov :: { self, DomaintypeId } ;
use chronicle::serde_json ;

# [ derive ( Clone , NewType ) ] # [ graphql ( name , visible = true ) ] pub struct CmsIdAttribute ( String ) ;# [ derive ( Clone , NewType ) ] # [ graphql ( name , visible = true ) ] pub struct ContentAttribute ( String ) ;# [ derive ( Clone , NewType ) ] # [ graphql ( name , visible = true ) ] pub struct ReferenceAttribute ( String ) ;# [ derive ( Clone , NewType ) ] # [ graphql ( name , visible = true ) ] pub struct SearchParameterAttribute ( String ) ;# [ derive ( Clone , NewType ) ] # [ graphql ( name , visible = true ) ] pub struct TitleAttribute ( String ) ;# [ derive ( Clone , NewType ) ] # [ graphql ( name , visible = true ) ] pub struct VersionAttribute ( i32 ) ;# [ derive ( async_graphql::Enum , Copy , Clone , Eq , PartialEq ) ] pub enum RoleType { Unspecified , Stakeholder,Author,Researcher,Editor, } impl Into < RoleType > for Option <prov::Role > { fn into ( self ) -> RoleType { match self . as_ref ( ) . map ( | x | x . as_str ( ) ) { None => { RoleType :: Unspecified } Some ( "Stakeholder" ) => { RoleType ::Stakeholder }Some ( "Author" ) => { RoleType ::Author }Some ( "Researcher" ) => { RoleType ::Researcher }Some ( "Editor" ) => { RoleType ::Editor } Some ( & _ ) => { RoleType :: Unspecified } } } } impl Into < Option <prov::Role >> for RoleType { fn into ( self ) -> Option <prov::Role > { match self { Self :: Unspecified => None , RoleType ::Stakeholder => { Some ( prov::Role :: from ( "Stakeholder" ) ) }RoleType ::Author => { Some ( prov::Role :: from ( "Author" ) ) }RoleType ::Researcher => { Some ( prov::Role :: from ( "Researcher" ) ) }RoleType ::Editor => { Some ( prov::Role :: from ( "Editor" ) ) } } } } # [ derive ( async_graphql::Enum , Copy , Clone , Eq , PartialEq ) ] pub enum AgentType { ProvAgent , Organization,Person, } impl Into < Option <prov::DomaintypeId >> for AgentType { fn into ( self ) -> Option <prov::DomaintypeId > { match self { AgentType ::Organization => Some ( prov::DomaintypeId :: from_name ( "Organization" ) ) ,AgentType ::Person => Some ( prov::DomaintypeId :: from_name ( "Person" ) ) , AgentType :: ProvAgent => None } } } # [ derive ( async_graphql::Enum , Copy , Clone , Eq , PartialEq ) ] pub enum EntityType { ProvEntity , Evidence,Guidance,PublishedGuidance,Question, } impl Into < Option <prov::DomaintypeId >> for EntityType { fn into ( self ) -> Option <prov::DomaintypeId > { match self { EntityType ::Evidence => Some ( prov::DomaintypeId :: from_name ( "Evidence" ) ) ,EntityType ::Guidance => Some ( prov::DomaintypeId :: from_name ( "Guidance" ) ) ,EntityType ::PublishedGuidance => Some ( prov::DomaintypeId :: from_name ( "PublishedGuidance" ) ) ,EntityType ::Question => Some ( prov::DomaintypeId :: from_name ( "Question" ) ) , EntityType :: ProvEntity => None } } } # [ derive ( async_graphql::Enum , Copy , Clone , Eq , PartialEq ) ] pub enum ActivityType { ProvActivity , Published,QuestionAsked,Researched,Revised, } impl Into < Option <prov::DomaintypeId >> for ActivityType { fn into ( self ) -> Option <prov::DomaintypeId > { match self { ActivityType ::Published => Some ( prov::DomaintypeId :: from_name ( "Published" ) ) ,ActivityType ::QuestionAsked => Some ( prov::DomaintypeId :: from_name ( "QuestionAsked" ) ) ,ActivityType ::Researched => Some ( prov::DomaintypeId :: from_name ( "Researched" ) ) ,ActivityType ::Revised => Some ( prov::DomaintypeId :: from_name ( "Revised" ) ) , ActivityType :: ProvActivity => None } } } # [ derive ( async_graphql::SimpleObject ) ] pub struct AgentRef { pub role : RoleType , pub agent : Agent , } # [ derive ( async_graphql::SimpleObject ) ] pub struct Association { pub responsible : AgentRef , pub delegate : Option < AgentRef >, } # [ derive ( async_graphql::InputObject , Clone ) ] pub struct ProvAgentAttributes { # [ graphql ( name = "type" ) ] pub typ : Option < String >, } # [ allow ( clippy :: from_over_into ) ] impl From < ProvAgentAttributes > for attributes::Attributes { fn from ( attributes : ProvAgentAttributes ) -> Self { Self { typ : attributes . typ . map ( prov::DomaintypeId :: from_name ) , .. Default :: default ( ) } } } # [ derive ( async_graphql::InputObject , Clone ) ] pub struct ProvEntityAttributes { # [ graphql ( name = "type" ) ] pub typ : Option < String >, } # [ allow ( clippy :: from_over_into ) ] impl From < ProvEntityAttributes > for attributes::Attributes { fn from ( attributes : ProvEntityAttributes ) -> Self { Self { typ : attributes . typ . map ( prov::DomaintypeId :: from_name ) , .. Default :: default ( ) } } } # [ derive ( async_graphql::InputObject , Clone ) ] pub struct ProvActivityAttributes { # [ graphql ( name = "type" ) ] pub typ : Option < String >, } # [ allow ( clippy :: from_over_into ) ] impl From < ProvActivityAttributes > for attributes::Attributes { fn from ( attributes : ProvActivityAttributes ) -> Self { Self { typ : attributes . typ . map ( prov::DomaintypeId :: from_name ) , .. Default :: default ( ) } } } # [ derive ( async_graphql::InputObject ) ] pub struct OrganizationAttributes { pub title_attribute : String , } # [ allow ( clippy :: from_over_into ) ] impl From <OrganizationAttributes > for attributes::Attributes { fn from ( attributes : OrganizationAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Organization" ) ) , attributes : vec ! [ ("Title" . to_owned ( ) , attributes::Attribute :: new ( "Title" , serde_json::Value :: from ( attributes .title_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } }# [ derive ( async_graphql::InputObject ) ] pub struct PersonAttributes { pub cms_id_attribute : String , } # [ allow ( clippy :: from_over_into ) ] impl From <PersonAttributes > for attributes::Attributes { fn from ( attributes : PersonAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Person" ) ) , attributes : vec ! [ ("CmsId" . to_owned ( ) , attributes::Attribute :: new ( "CmsId" , serde_json::Value :: from ( attributes .cms_id_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } } # [ derive ( async_graphql::InputObject ) ] pub struct PublishedAttributes { pub version_attribute : i32 , } # [ allow ( clippy :: from_over_into ) ] impl From <PublishedAttributes > for attributes::Attributes { fn from ( attributes : PublishedAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Published" ) ) , attributes : vec ! [ ("Version" . to_owned ( ) , attributes::Attribute :: new ( "Version" , serde_json::Value :: from ( attributes .version_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } }# [ derive ( async_graphql::InputObject ) ] pub struct QuestionAskedAttributes { pub content_attribute : String , } # [ allow ( clippy :: from_over_into ) ] impl From <QuestionAskedAttributes > for attributes::Attributes { fn from ( attributes : QuestionAskedAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "QuestionAsked" ) ) , attributes : vec ! [ ("Content" . to_owned ( ) , attributes::Attribute :: new ( "Content" , serde_json::Value :: from ( attributes .content_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } }# [ derive ( async_graphql::InputObject ) ] pub struct RevisedAttributes { pub cms_id_attribute : String ,pub version_attribute : i32 , } # [ allow ( clippy :: from_over_into ) ] impl From <RevisedAttributes > for attributes::Attributes { fn from ( attributes : RevisedAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Revised" ) ) , attributes : vec ! [ ("CmsId" . to_owned ( ) , attributes::Attribute :: new ( "CmsId" , serde_json::Value :: from ( attributes .cms_id_attribute ) ) ) ,("Version" . to_owned ( ) , attributes::Attribute :: new ( "Version" , serde_json::Value :: from ( attributes .version_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } } # [ derive ( async_graphql::InputObject ) ] pub struct EvidenceAttributes { pub search_parameter_attribute : String ,pub reference_attribute : String , } # [ allow ( clippy :: from_over_into ) ] impl From <EvidenceAttributes > for attributes::Attributes { fn from ( attributes : EvidenceAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Evidence" ) ) , attributes : vec ! [ ("SearchParameter" . to_owned ( ) , attributes::Attribute :: new ( "SearchParameter" , serde_json::Value :: from ( attributes .search_parameter_attribute ) ) ) ,("Reference" . to_owned ( ) , attributes::Attribute :: new ( "Reference" , serde_json::Value :: from ( attributes .reference_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } }# [ derive ( async_graphql::InputObject ) ] pub struct GuidanceAttributes { pub title_attribute : String ,pub version_attribute : i32 , } # [ allow ( clippy :: from_over_into ) ] impl From <GuidanceAttributes > for attributes::Attributes { fn from ( attributes : GuidanceAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Guidance" ) ) , attributes : vec ! [ ("Title" . to_owned ( ) , attributes::Attribute :: new ( "Title" , serde_json::Value :: from ( attributes .title_attribute ) ) ) ,("Version" . to_owned ( ) , attributes::Attribute :: new ( "Version" , serde_json::Value :: from ( attributes .version_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } }# [ derive ( async_graphql::InputObject ) ] pub struct QuestionAttributes { pub cms_id_attribute : String ,pub content_attribute : String , } # [ allow ( clippy :: from_over_into ) ] impl From <QuestionAttributes > for attributes::Attributes { fn from ( attributes : QuestionAttributes ) -> Self { attributes::Attributes { typ : Some ( prov::DomaintypeId :: from_name ( "Question" ) ) , attributes : vec ! [ ("CmsId" . to_owned ( ) , attributes::Attribute :: new ( "CmsId" , serde_json::Value :: from ( attributes .cms_id_attribute ) ) ) ,("Content" . to_owned ( ) , attributes::Attribute :: new ( "Content" , serde_json::Value :: from ( attributes .content_attribute ) ) ) , ] . into_iter ( ) . collect ( ) , } } } # [ allow ( clippy :: enum_variant_names ) ] # [ derive ( async_graphql::Union ) ] pub enum Agent { ProvAgent ( ProvAgent ) , Organization( Organization ) ,Person( Person ) , } # [ allow ( clippy :: enum_variant_names ) ] # [ derive ( async_graphql::Union ) ] pub enum Entity { ProvEntity ( ProvEntity ) , Evidence( Evidence ) ,Guidance( Guidance ) ,PublishedGuidance( PublishedGuidance ) ,Question( Question ) , } # [ allow ( clippy :: enum_variant_names ) ] # [ derive ( async_graphql::Union ) ] pub enum Activity { ProvActivity ( ProvActivity ) , Published( Published ) ,QuestionAsked( QuestionAsked ) ,Researched( Researched ) ,Revised( Revised ) , } fn map_agent_to_domain_type ( agent : chronicle_graphql::Agent ) -> Agent { match agent . domaintype . as_deref ( ) { Some ( "Organization" ) => Agent ::Organization ( Organization ( agent ) ) ,Some ( "Person" ) => Agent ::Person ( Person ( agent ) ) , _ => Agent :: ProvAgent ( ProvAgent ( agent ) ) } } # [ doc = " Maps to an association, missing roles, or ones that are no longer specifified in the domain will be returned as RoleType::Unspecified" ] fn map_association_to_role ( responsible : chronicle_graphql::Agent , delegate : Option <chronicle_graphql::Agent >, responsible_role : Option <prov::Role >, delegate_role : Option <prov::Role > ) -> Association { Association { responsible : match responsible_role . as_ref ( ) . map ( | x | x . as_str ( ) ) { None => { AgentRef { agent : map_agent_to_domain_type ( responsible ) , role : RoleType :: Unspecified } } , Some ( "Stakeholder" ) => { AgentRef { role : RoleType ::Stakeholder , agent : map_agent_to_domain_type ( responsible ) } }Some ( "Author" ) => { AgentRef { role : RoleType ::Author , agent : map_agent_to_domain_type ( responsible ) } }Some ( "Researcher" ) => { AgentRef { role : RoleType ::Researcher , agent : map_agent_to_domain_type ( responsible ) } }Some ( "Editor" ) => { AgentRef { role : RoleType ::Editor , agent : map_agent_to_domain_type ( responsible ) } } Some ( & _ ) => { AgentRef { agent : map_agent_to_domain_type ( responsible ) , role : RoleType :: Unspecified } } } , delegate : match ( delegate , delegate_role . as_ref ( ) . map ( | x | x . as_str ( ) ) ) { ( None , _ ) => None , ( Some ( delegate ) , None ) => { Some ( AgentRef { role : RoleType :: Unspecified , agent : map_agent_to_domain_type ( delegate ) } ) } , (Some ( delegate ) , Some ( "Stakeholder" ) ) => { Some ( AgentRef { role : RoleType ::Stakeholder , agent : map_agent_to_domain_type ( delegate ) } ) }(Some ( delegate ) , Some ( "Author" ) ) => { Some ( AgentRef { role : RoleType ::Author , agent : map_agent_to_domain_type ( delegate ) } ) }(Some ( delegate ) , Some ( "Researcher" ) ) => { Some ( AgentRef { role : RoleType ::Researcher , agent : map_agent_to_domain_type ( delegate ) } ) }(Some ( delegate ) , Some ( "Editor" ) ) => { Some ( AgentRef { role : RoleType ::Editor , agent : map_agent_to_domain_type ( delegate ) } ) } ( Some ( delegate ) , Some ( & _ ) ) => { Some ( AgentRef { role : RoleType :: Unspecified , agent : map_agent_to_domain_type ( delegate ) } ) } , } } } fn map_activity_to_domain_type ( activity : chronicle_graphql::Activity ) -> Activity { match activity . domaintype . as_deref ( ) { Some ( "Published" ) => Activity ::Published ( Published ( activity ) ) ,Some ( "QuestionAsked" ) => Activity ::QuestionAsked ( QuestionAsked ( activity ) ) ,Some ( "Researched" ) => Activity ::Researched ( Researched ( activity ) ) ,Some ( "Revised" ) => Activity ::Revised ( Revised ( activity ) ) , _ => Activity :: ProvActivity ( ProvActivity ( activity ) ) } } fn map_entity_to_domain_type ( entity : chronicle_graphql::Entity ) -> Entity { match entity . domaintype . as_deref ( ) { Some ( "Evidence" ) => Entity ::Evidence ( Evidence ( entity ) ) ,Some ( "Guidance" ) => Entity ::Guidance ( Guidance ( entity ) ) ,Some ( "PublishedGuidance" ) => Entity ::PublishedGuidance ( PublishedGuidance ( entity ) ) ,Some ( "Question" ) => Entity ::Question ( Question ( entity ) ) , _ => Entity :: ProvEntity ( ProvEntity ( entity ) ) } } pub struct ProvAgent ( chronicle_graphql::Agent ) ; # [ async_graphql::Object ] impl ProvAgent { async fn id ( & self ) -> prov::AgentId { prov::AgentId :: from_name ( &* self . 0 . name ) } async fn name ( & self ) -> & str { & self . 0 . name } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::agent :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn identity < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Identity >> { chronicle_graphql::agent :: identity ( self . 0 . identity_id , ctx ) . await } async fn acted_on_behalf_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec < AgentRef >> { Ok ( chronicle_graphql::agent :: acted_on_behalf_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | ( Self ( agent ) , role ) ) . map ( | ( agent , role ) | AgentRef { agent : Agent :: from ( agent ) , role : role . into ( ) } ) . collect ( ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } } pub struct ProvActivity ( chronicle_graphql::Activity ) ; # [ async_graphql::Object ] impl ProvActivity { async fn id ( & self ) -> prov::ActivityId { prov::ActivityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::activity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } async fn started ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . started . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } async fn ended ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . ended . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( DomaintypeId :: from_name ) } async fn was_associated_with < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec < Association >> { Ok ( chronicle_graphql::activity :: was_associated_with ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | map_association_to_role ( agent , None , role , None ) ) . collect ( ) , ) } async fn used < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::activity :: used ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } } pub struct ProvEntity ( chronicle_graphql::Entity ) ; # [ async_graphql::Object ] impl ProvEntity { async fn id ( & self ) -> prov::EntityId { prov::EntityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::entity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } async fn evidence < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Evidence >> { chronicle_graphql::entity :: evidence ( self . 0 . attachment_id , ctx ) . await } async fn was_generated_by < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Activity >> { Ok ( chronicle_graphql::entity :: was_generated_by ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_activity_to_domain_type ) . collect ( ) ) } async fn was_derived_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_derived_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn had_primary_source < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: had_primary_source ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) , ) } async fn was_revision_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_revision_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn was_quoted_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_quoted_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } } pub struct Organization ( chronicle_graphql::Agent ) ; # [ async_graphql::Object ] impl Organization { async fn id ( & self ) -> prov::AgentId { prov::AgentId :: from_name ( &* self . 0 . name ) } async fn name ( & self ) -> & str { & self . 0 . name } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::agent :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn identity < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Identity >> { chronicle_graphql::agent :: identity ( self . 0 . identity_id , ctx ) . await } async fn acted_on_behalf_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec < AgentRef >> { Ok ( chronicle_graphql::agent :: acted_on_behalf_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | ( Self ( agent ) , role ) ) . map ( | ( agent , role ) | AgentRef { agent : Agent :: from ( agent ) , role : role . into ( ) } ) . collect ( ) ) } async fn title_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <TitleAttribute >> { Ok ( chronicle_graphql::agent:: load_attribute ( self . 0 . id , "Title" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( TitleAttribute ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } }pub struct Person ( chronicle_graphql::Agent ) ; # [ async_graphql::Object ] impl Person { async fn id ( & self ) -> prov::AgentId { prov::AgentId :: from_name ( &* self . 0 . name ) } async fn name ( & self ) -> & str { & self . 0 . name } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::agent :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn identity < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Identity >> { chronicle_graphql::agent :: identity ( self . 0 . identity_id , ctx ) . await } async fn acted_on_behalf_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec < AgentRef >> { Ok ( chronicle_graphql::agent :: acted_on_behalf_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | ( Self ( agent ) , role ) ) . map ( | ( agent , role ) | AgentRef { agent : Agent :: from ( agent ) , role : role . into ( ) } ) . collect ( ) ) } async fn cms_id_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <CmsIdAttribute >> { Ok ( chronicle_graphql::agent:: load_attribute ( self . 0 . id , "CmsId" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( CmsIdAttribute ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } } pub struct Published ( chronicle_graphql::Activity ) ; # [ async_graphql::Object ] impl Published { async fn id ( & self ) -> prov::ActivityId { prov::ActivityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::activity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } async fn started ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . started . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } async fn ended ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . ended . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( DomaintypeId :: from_name ) } async fn was_associated_with < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec < Association >> { Ok ( chronicle_graphql::activity :: was_associated_with ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | map_association_to_role ( agent , None , role , None ) ) . collect ( ) , ) } async fn used < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::activity :: used ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn version_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <VersionAttribute >> { Ok ( chronicle_graphql::activity:: load_attribute ( self . 0 . id , "Version" , ctx ) . await ? . and_then ( | attr | attr . as_i64 ( ) . map ( | attr | attr as _ ) ) . map ( VersionAttribute ) ) } }pub struct QuestionAsked ( chronicle_graphql::Activity ) ; # [ async_graphql::Object ] impl QuestionAsked { async fn id ( & self ) -> prov::ActivityId { prov::ActivityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::activity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } async fn started ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . started . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } async fn ended ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . ended . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( DomaintypeId :: from_name ) } async fn was_associated_with < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec < Association >> { Ok ( chronicle_graphql::activity :: was_associated_with ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | map_association_to_role ( agent , None , role , None ) ) . collect ( ) , ) } async fn used < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::activity :: used ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn content_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <ContentAttribute >> { Ok ( chronicle_graphql::activity:: load_attribute ( self . 0 . id , "Content" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( ContentAttribute ) ) } }pub struct Researched ( chronicle_graphql::Activity ) ; # [ async_graphql::Object ] impl Researched { async fn id ( & self ) -> prov::ActivityId { prov::ActivityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::activity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } async fn started ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . started . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } async fn ended ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . ended . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( DomaintypeId :: from_name ) } async fn was_associated_with < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec < Association >> { Ok ( chronicle_graphql::activity :: was_associated_with ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | map_association_to_role ( agent , None , role , None ) ) . collect ( ) , ) } async fn used < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::activity :: used ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } }pub struct Revised ( chronicle_graphql::Activity ) ; # [ async_graphql::Object ] impl Revised { async fn id ( & self ) -> prov::ActivityId { prov::ActivityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::activity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } async fn started ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . started . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } async fn ended ( & self ) -> Option <chrono::DateTime <chrono::Utc >> { self . 0 . ended . map ( | x | chrono::DateTime :: from_utc ( x , chrono::Utc ) ) } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( DomaintypeId :: from_name ) } async fn was_associated_with < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec < Association >> { Ok ( chronicle_graphql::activity :: was_associated_with ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( | ( agent , role ) | map_association_to_role ( agent , None , role , None ) ) . collect ( ) , ) } async fn used < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::activity :: used ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn cms_id_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <CmsIdAttribute >> { Ok ( chronicle_graphql::activity:: load_attribute ( self . 0 . id , "CmsId" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( CmsIdAttribute ) ) }async fn version_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <VersionAttribute >> { Ok ( chronicle_graphql::activity:: load_attribute ( self . 0 . id , "Version" , ctx ) . await ? . and_then ( | attr | attr . as_i64 ( ) . map ( | attr | attr as _ ) ) . map ( VersionAttribute ) ) } } pub struct Evidence ( chronicle_graphql::Entity ) ; # [ async_graphql::Object ] impl Evidence { async fn id ( & self ) -> prov::EntityId { prov::EntityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::entity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } async fn evidence < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Evidence >> { chronicle_graphql::entity :: evidence ( self . 0 . attachment_id , ctx ) . await } async fn was_generated_by < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Activity >> { Ok ( chronicle_graphql::entity :: was_generated_by ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_activity_to_domain_type ) . collect ( ) ) } async fn was_derived_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_derived_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn had_primary_source < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: had_primary_source ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) , ) } async fn was_revision_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_revision_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn was_quoted_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_quoted_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn search_parameter_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <SearchParameterAttribute >> { Ok ( chronicle_graphql::entity:: load_attribute ( self . 0 . id , "SearchParameter" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( SearchParameterAttribute ) ) }async fn reference_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <ReferenceAttribute >> { Ok ( chronicle_graphql::entity:: load_attribute ( self . 0 . id , "Reference" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( ReferenceAttribute ) ) } }pub struct Guidance ( chronicle_graphql::Entity ) ; # [ async_graphql::Object ] impl Guidance { async fn id ( & self ) -> prov::EntityId { prov::EntityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::entity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } async fn evidence < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Evidence >> { chronicle_graphql::entity :: evidence ( self . 0 . attachment_id , ctx ) . await } async fn was_generated_by < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Activity >> { Ok ( chronicle_graphql::entity :: was_generated_by ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_activity_to_domain_type ) . collect ( ) ) } async fn was_derived_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_derived_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn had_primary_source < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: had_primary_source ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) , ) } async fn was_revision_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_revision_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn was_quoted_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_quoted_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn title_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <TitleAttribute >> { Ok ( chronicle_graphql::entity:: load_attribute ( self . 0 . id , "Title" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( TitleAttribute ) ) }async fn version_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <VersionAttribute >> { Ok ( chronicle_graphql::entity:: load_attribute ( self . 0 . id , "Version" , ctx ) . await ? . and_then ( | attr | attr . as_i64 ( ) . map ( | attr | attr as _ ) ) . map ( VersionAttribute ) ) } }pub struct PublishedGuidance ( chronicle_graphql::Entity ) ; # [ async_graphql::Object ] impl PublishedGuidance { async fn id ( & self ) -> prov::EntityId { prov::EntityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::entity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } async fn evidence < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Evidence >> { chronicle_graphql::entity :: evidence ( self . 0 . attachment_id , ctx ) . await } async fn was_generated_by < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Activity >> { Ok ( chronicle_graphql::entity :: was_generated_by ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_activity_to_domain_type ) . collect ( ) ) } async fn was_derived_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_derived_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn had_primary_source < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: had_primary_source ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) , ) } async fn was_revision_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_revision_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn was_quoted_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_quoted_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } }pub struct Question ( chronicle_graphql::Entity ) ; # [ async_graphql::Object ] impl Question { async fn id ( & self ) -> prov::EntityId { prov::EntityId :: from_name ( &* self . 0 . name ) } async fn namespace < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result <chronicle_graphql::Namespace > { chronicle_graphql::entity :: namespace ( self . 0 . namespace_id , ctx ) . await } async fn name ( & self ) -> & str { & self . 0 . name } # [ graphql ( name = "type" ) ] async fn typ ( & self ) -> Option <prov::DomaintypeId > { self . 0 . domaintype . as_deref ( ) . map ( prov::DomaintypeId :: from_name ) } async fn evidence < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <chronicle_graphql::Evidence >> { chronicle_graphql::entity :: evidence ( self . 0 . attachment_id , ctx ) . await } async fn was_generated_by < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Activity >> { Ok ( chronicle_graphql::entity :: was_generated_by ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_activity_to_domain_type ) . collect ( ) ) } async fn was_derived_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_derived_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn had_primary_source < 'a > ( & self , ctx : &async_graphql::Context < 'a >, ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: had_primary_source ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) , ) } async fn was_revision_of < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_revision_of ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn was_quoted_from < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Vec <Entity >> { Ok ( chronicle_graphql::entity :: was_quoted_from ( self . 0 . id , ctx ) . await ? . into_iter ( ) . map ( map_entity_to_domain_type ) . collect ( ) ) } async fn cms_id_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <CmsIdAttribute >> { Ok ( chronicle_graphql::entity:: load_attribute ( self . 0 . id , "CmsId" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( CmsIdAttribute ) ) }async fn content_attribute < 'a > ( & self , ctx : &async_graphql::Context < 'a > ) -> async_graphql::Result < Option <ContentAttribute >> { Ok ( chronicle_graphql::entity:: load_attribute ( self . 0 . id , "Content" , ctx ) . await ? . and_then ( | attr | attr . as_str ( ) . map ( | attr | attr . to_owned ( ) ) ) . map ( ContentAttribute ) ) } } # [ derive ( Copy , Clone ) ] pub struct Query ; # [ async_graphql::Object ] impl Query { # [ allow ( clippy :: too_many_arguments ) ] pub async fn activity_timeline < 'a > ( & self , ctx : &async_graphql::Context < 'a >, activity_types : Vec < ActivityType >, for_entity : Vec <prov::EntityId >, from : Option <chrono::DateTime <chrono::Utc >>, to : Option <chrono::DateTime <chrono::Utc >>, namespace : Option <async_graphql::ID >, after : Option < String >, before : Option < String >, first : Option < i32 >, last : Option < i32 >, ) -> async_graphql::Result <connection::Connection < i32 , Activity , connection::EmptyFields , connection::EmptyFields >> { Ok ( chronicle_graphql::query :: activity_timeline ( ctx , activity_types . into_iter ( ) . filter_map ( | x | x . into ( ) ) . collect ( ) , for_entity , from , to , namespace , after , before , first , last , ) . await ? . map_node ( map_activity_to_domain_type ) ) } # [ allow ( clippy :: too_many_arguments ) ] pub async fn agents_by_type < 'a > ( & self , ctx : &async_graphql::Context < 'a >, agent_type : AgentType , namespace : Option < String >, after : Option < String >, before : Option < String >, first : Option < i32 >, last : Option < i32 >, ) -> async_graphql::Result <connection::Connection < i32 , Agent , connection::EmptyFields , connection::EmptyFields >> { Ok ( chronicle_graphql::query :: agents_by_type ( ctx , agent_type . into ( ) , namespace , after , before , first , last , ) . await ? . map_node ( map_agent_to_domain_type ) ) } pub async fn agent_by_id < 'a > ( & self , ctx : &async_graphql::Context < 'a >, id : prov::AgentId , namespace : Option < String >, ) -> async_graphql::Result < Option <Agent >> { Ok ( chronicle_graphql::query :: agent_by_id ( ctx , id , namespace ) . await ? . map ( map_agent_to_domain_type ) ) } pub async fn entity_by_id < 'a > ( & self , ctx : &async_graphql::Context < 'a >, id : prov::EntityId , namespace : Option < String >, ) -> async_graphql::Result < Option <Entity >> { Ok ( chronicle_graphql::query :: entity_by_id ( ctx , id , namespace ) . await ? . map ( map_entity_to_domain_type ) ) } } # [ derive ( Copy , Clone ) ] pub struct Mutation ; # [ async_graphql::Object ] impl Mutation { pub async fn agent < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : ProvAgentAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: agent ( ctx , name , namespace , attributes . into ( ) ) . await } pub async fn organization < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : OrganizationAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: agent ( ctx , name , namespace , attributes . into ( ) ) . await }pub async fn person < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : PersonAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: agent ( ctx , name , namespace , attributes . into ( ) ) . await } pub async fn activity < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : ProvActivityAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: activity ( ctx , name , namespace , attributes . into ( ) ) . await } pub async fn published < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : PublishedAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: activity ( ctx , name , namespace , attributes . into ( ) ) . await }pub async fn question_asked < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : QuestionAskedAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: activity ( ctx , name , namespace , attributes . into ( ) ) . await }pub async fn researched < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: activity ( ctx , name , namespace , attributes::Attributes :: type_only ( Some ( prov::DomaintypeId :: from_name ( "Researched" ) ) ) ) . await }pub async fn revised < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : RevisedAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: activity ( ctx , name , namespace , attributes . into ( ) ) . await } pub async fn entity < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : ProvEntityAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: entity ( ctx , name , namespace , attributes . into ( ) ) . await } pub async fn evidence < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : EvidenceAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: entity ( ctx , name , namespace , attributes . into ( ) ) . await }pub async fn guidance < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : GuidanceAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: entity ( ctx , name , namespace , attributes . into ( ) ) . await }pub async fn published_guidance < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: entity ( ctx , name , namespace , attributes::Attributes :: type_only ( Some ( prov::DomaintypeId :: from_name ( "PublishedGuidance" ) ) ) ) . await }pub async fn question < 'a > ( & self , ctx : &async_graphql::Context < 'a >, name : String , namespace : Option < String >, attributes : QuestionAttributes , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: entity ( ctx , name , namespace , attributes . into ( ) ) . await } pub async fn acted_on_behalf_of < 'a > ( & self , ctx : &async_graphql::Context < 'a >, namespace : Option < String >, responsible : prov::AgentId , delegate : prov::AgentId , activity : Option <prov::ActivityId >, role : RoleType , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: acted_on_behalf_of ( ctx , namespace , responsible , delegate , activity , role . into ( ) ) . await } pub async fn was_derived_from < 'a > ( & self , ctx : &async_graphql::Context < 'a >, namespace : Option < String >, generated_entity : prov::EntityId , used_entity : prov::EntityId , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: was_derived_from ( ctx , namespace , generated_entity , used_entity ) . await } pub async fn was_revision_of < 'a > ( & self , ctx : &async_graphql::Context < 'a >, namespace : Option < String >, generated_entity : prov::EntityId , used_entity : prov::EntityId , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: was_revision_of ( ctx , namespace , generated_entity , used_entity ) . await } pub async fn had_primary_source < 'a > ( & self , ctx : &async_graphql::Context < 'a >, namespace : Option < String >, generated_entity : prov::EntityId , used_entity : prov::EntityId , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: had_primary_source ( ctx , namespace , generated_entity , used_entity , ) . await } pub async fn was_quoted_from < 'a > ( & self , ctx : &async_graphql::Context < 'a >, namespace : Option < String >, generated_entity : prov::EntityId , used_entity : prov::EntityId , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: was_quoted_from ( ctx , namespace , generated_entity , used_entity ) . await } pub async fn generate_key < 'a > ( & self , ctx : &async_graphql::Context < 'a >, id : prov::AgentId , namespace : Option < String >, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: generate_key ( ctx , id , namespace ) . await } pub async fn start_activity < 'a > ( & self , ctx : &async_graphql::Context < 'a >, id : prov::ActivityId , namespace : Option < String >, agent : Option <prov::AgentId >, time : Option <chrono::DateTime <chrono::Utc >>, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: start_activity ( ctx , id , namespace , agent , time ) . await } pub async fn end_activity < 'a > ( & self , ctx : &async_graphql::Context < 'a >, id : prov::ActivityId , namespace : Option < String >, agent : Option <prov::AgentId >, time : Option <chrono::DateTime <chrono::Utc >>, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: end_activity ( ctx , id , namespace , agent , time ) . await } pub async fn was_associated_with < 'a > ( & self , ctx : &async_graphql::Context < 'a >, namespace : Option < String >, responsible : prov::AgentId , activity : prov::ActivityId , role : RoleType ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: was_associated_with ( ctx , namespace , responsible , activity , role . into ( ) ) . await } pub async fn used < 'a > ( & self , ctx : &async_graphql::Context < 'a >, activity : prov::ActivityId , id : prov::EntityId , namespace : Option < String >, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: used ( ctx , activity , id , namespace ) . await } pub async fn was_generated_by < 'a > ( & self , ctx : &async_graphql::Context < 'a >, activity : prov::ActivityId , id : prov::EntityId , namespace : Option < String >, ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: was_generated_by ( ctx , activity , id , namespace ) . await } pub async fn has_attachment < 'a > ( & self , ctx : &async_graphql::Context < 'a >, id : prov::EntityId , namespace : Option < String >, attachment : async_graphql::Upload , agent : prov::AgentId , locator : String , ) -> async_graphql::Result <chronicle_graphql::Submission > { chronicle_graphql::mutation :: has_attachment ( ctx , id , namespace , attachment , agent , locator ) . await } } # [ tokio :: main ] pub async fn main ( ) { let model = ChronicleDomainDef :: from_input_string ( "{\"name\":\"evidence\",\"attributes\":{\"CmsId\":{\"type\":\"String\"},\"Content\":{\"type\":\"String\"},\"Reference\":{\"type\":\"String\"},\"SearchParameter\":{\"type\":\"String\"},\"Title\":{\"type\":\"String\"},\"Version\":{\"type\":\"Int\"}},\"agents\":{\"Organization\":{\"attributes\":[\"Title\"]},\"Person\":{\"attributes\":[\"CmsId\"]}},\"entities\":{\"Evidence\":{\"attributes\":[\"SearchParameter\",\"Reference\"]},\"Guidance\":{\"attributes\":[\"Title\",\"Version\"]},\"PublishedGuidance\":{\"attributes\":[]},\"Question\":{\"attributes\":[\"CmsId\",\"Content\"]}},\"activities\":{\"Published\":{\"attributes\":[\"Version\"]},\"QuestionAsked\":{\"attributes\":[\"Content\"]},\"Researched\":{\"attributes\":[]},\"Revised\":{\"attributes\":[\"CmsId\",\"Version\"]}},\"roles\":[\"Stakeholder\",\"Author\",\"Researcher\",\"Editor\"]}" ) . unwrap ( ) ; bootstrap ( model , ChronicleGraphQl :: new ( Query , Mutation ) ) . await }
